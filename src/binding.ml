open Interface
open Format

let header = {|(* This file has been generated by coq-bindgen. *)

From FreeSpec.Core Require Import All.|}

let is_not_empty = function
  | _ :: _ -> true
  | _ -> false

let open_parens fmt cond =
  fprintf fmt "%s" (if cond then "(" else "")

let close_parens fmt cond =
  fprintf fmt "%s" (if cond then ")" else "")

let rec print_type_tree ~param fmt = function
  | ArrowNode(l,r) ->
    fprintf fmt "%a%a -> %a%a"
      open_parens param
      (print_type_tree ~param:true) l
      (print_type_tree ~param:true) r
      close_parens param
  | TypeLeaf leaf ->
    print_type_leaf ~param:param fmt leaf

and print_type_leaf ~param fmt (name, ts) =
  let with_parens = param && is_not_empty ts in
  fprintf fmt "%a%s" open_parens with_parens name;
  List.iter (fun x -> fprintf fmt " %a" (print_type_tree ~param:true) x) ts;
  close_parens fmt with_parens

let print_type fmt t =
  if is_not_empty t.poly_vars
  then begin
    fprintf fmt "forall%a, "
      (fun fmt -> List.iter (fun x -> fprintf fmt " (%s : Type)" x))
      t.poly_vars;
  end;
  fprintf fmt "%a -> %a"
    (print_type_tree ~param:true) t.domain_types
    (print_type_leaf ~param:false) t.codomain_type

let print_coq_type fmt (t : type_entry) =
  let name = Ident.name t.name in
  match t.coq_model with
  | Some ident ->
    fprintf fmt "Definition %s : Type := %@%s.\n" name ident
  | None ->
    fprintf fmt "Axiom (%s : Type).\n" name

let print_coq_types fmt i =
  List.iter (print_coq_type fmt) i.types

let print_coq_function modname fmt (t : function_entry) =
  let name = Ident.name t.name in
  begin
    match t.coq_model with
    | Some ident ->
      fprintf fmt "Definition %s : %a := %@%s.\n"
        name
        print_type t.type_sig
        ident
    | None ->
      fprintf fmt "Axiom (%s : %a).\n"
        name
        print_type t.type_sig
  end;
  fprintf fmt "Extract Constant %s => \"%s\".\n"
    name
    (String.concat "." modname ^ "." ^ name)

let print_coq_primitive iname fmt p =
  let pname = String.capitalize_ascii @@ Ident.name p.name in
  fprintf fmt "\n| %s : %a -> %s %a"
    pname
    (print_type_tree ~param:true) p.type_sig.domain_types
    iname
    (print_type_leaf ~param:true) p.type_sig.codomain_type

let print_coq_primitives fmt i =
  let rec last = function
    | [x] -> x
    | _ :: rst -> last rst
    | _ -> raise (UnsupportedOcaml "Found an empty ident") in
  let name = String.uppercase_ascii (last i.module_path) in
  fprintf fmt "Inductive %s : interface :=%a.\n"
    name
    (fun fmt -> List.iter (print_coq_primitive name fmt)) i.primitives

let print_coq_functions fmt i =
  List.iter (print_coq_function i.module_path fmt) i.functions

let print_coq_interface fmt i =
  fprintf fmt "%s\n%a\n%a\n%a"
    header
    print_coq_types i
    print_coq_functions i
    print_coq_primitives i
