open Interface

let header = {|(* This file has been generated by coq-bindgen. *)

From Base Require Import Prelude.
From FreeSpec.Core Require Import All.|}

let is_not_empty = function
  | _ :: _ -> true
  | _ -> false

let rec print_type_tree param = function
  | ArrowNode(l,r) ->
    if param then print_string "(";
    print_type_tree true l;
    print_string " -> ";
    print_type_tree true r;
    if param then print_string ")";
  | TypeLeaf leaf ->
    print_type_leaf param leaf

and print_type_leaf param (name, ts) =
  let print_parens = param && is_not_empty ts in
  if print_parens then print_string "(";
  print_string name;
  List.iter (fun x -> print_string " "; print_type_tree true x) ts;
  if print_parens then print_string ")"

let print_type t =
  if is_not_empty t.poly_vars
  then begin
    print_string "forall";
    List.iter (fun x -> print_string @@ " (" ^ x ^ " : Type)") t.poly_vars;
    print_string ", "
  end;
  print_type_tree true t.domain_types;
  print_string " -> ";
  print_type_leaf false t.codomain_type

let print_coq_type (t : type_entry) =
  let name = Ident.name t.name in
  match t.coq_model with
  | Some ident ->
    print_string @@ "Definition " ^ name ^ " : Type :=\n";
    print_string @@ "  " ^ ident ^ "."
  | None ->
    print_string @@ "Axiom " ^ name ^ " : Type."

let print_coq_types i =
  List.iter print_coq_type i.types

let print_coq_function modname (t : function_entry) =
  let name = Ident.name t.name in
  begin
    match t.coq_model with
    | Some ident ->
      print_string @@ "Definition " ^ name ^ " : ";
      print_type t.type_sig;
      print_string " :=\n";
      print_string @@ "  " ^ ident ^ ".\n"
    | None ->
      print_string @@ "Axiom (" ^ name ^ " : ";
      print_type t.type_sig;
      print_string ").\n";
  end;
  print_string @@ "Extract Constant " ^ name ^ " => ";
  print_string @@ "\"" ^ String.concat "." modname ^ "." ^ name ^ "\".\n"

let print_coq_primitive iname p =
  let pname = String.capitalize_ascii @@ Ident.name p.name in
  print_string @@ "\n| " ^ pname ^ " : ";
  print_type_tree true p.type_sig.domain_types;
  print_string @@ " -> " ^ iname ^ " ";
  print_type_leaf true p.type_sig.codomain_type

let print_coq_primitives i =
  let rec last = function
    | [x] -> x
    | _ :: rst -> last rst
    | _ -> assert false in
  let name = String.uppercase_ascii (last i.module_path) in
  print_string @@ "Inductive " ^ name ^ " : interface :=";
  List.iter (print_coq_primitive name) i.primitives;
  print_string "."

let print_coq_functions i =
  List.iter (print_coq_function i.module_path) i.functions

let print_coq_interface i =
  print_string header;
  print_newline ();
  print_coq_types i;
  print_newline ();
  print_coq_functions i;
  print_newline ();
  print_coq_primitives i
